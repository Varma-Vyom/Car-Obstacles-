<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated 3D Car Racing Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom styles for game elements */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            margin: 0;
            overflow: hidden; /* Prevent scrollbars from popping up */
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            background-color: #333; /* Road color */
            border-radius: 12px; /* Rounded corners for the canvas */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh; /* Full viewport height */
            padding: 16px;
        }
        .score-board {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1rem 1.5rem;
            margin-bottom: 1.5rem;
            width: 100%;
            max-width: 500px; /* Match canvas width */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .controls-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        .control-button {
            padding: 1rem 2rem;
            background-color: #3b82f6; /* Blue button */
            color: white;
            font-size: 1.25rem;
            font-weight: bold;
            border-radius: 9999px; /* Full rounded */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-in-out;
        }
        .control-button:hover {
            background-color: #2563eb;
            transform: translateY(-2px);
        }
        .control-button:active {
            background-color: #1d4ed8;
            transform: translateY(0);
        }
        .message-box {
            position: fixed; /* Fixed to cover the whole screen */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            text-align: center;
            z-index: 1000;
            backdrop-filter: blur(5px); /* Optional: blur background */
        }
        .message-button {
            margin-top: 20px;
            padding: 12px 24px;
            background-color: #ef4444; /* Red button */
            border-radius: 9999px;
            font-size: 1.2rem;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .message-button:hover {
            background-color: #dc2626;
            transform: translateY(-2px);
        }
        .message-button:active {
            background-color: #1d4ed8;
            transform: translateY(0);
        }
        .start-button-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        .start-button {
            padding: 1.5rem 3rem;
            background-color: #22c55e; /* Green button */
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 9999px;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease-in-out;
        }
        .start-button:hover {
            background-color: #16a34a;
            transform: translate(-50%, -50%) scale(1.05);
        }
        .start-button:active {
            background-color: #15803d;
            transform: translate(-50%, -50%) scale(0.98);
        }
    </style>
</head>
<body class="bg-gray-900">

    <div class="game-container">
        <h1 class="text-4xl md:text-5xl font-extrabold text-white mb-6 text-center drop-shadow-lg">
            3D Car Dash Animated
        </h1>

        <div class="score-board">
            <p class="text-2xl font-bold text-gray-800">Score: <span id="scoreDisplay">0</span></p>
            <p class="text-lg text-gray-600"><b>Vyom Varma</b></p>
            <button id="restartButton" class="px-6 py-2 bg-green-500 text-white font-semibold rounded-full shadow-md hover:bg-green-600 transform hover:scale-105 transition duration-300 ease-in-out hidden">
                Restart Game
            </button>
        </div>

        <canvas id="gameCanvas" class="w-full max-w-lg h-96"></canvas>

        <div id="touchControlArea" class="controls-container hidden"></div>
    </div>

    <div id="startButtonContainer" class="start-button-container">
        <button id="startButton" class="start-button">Start Game</button>
    </div>

    <div id="messageBox" class="message-box hidden">
        <p id="messageText" class="text-white text-4xl mb-4"></p>
        <button id="messageBoxButton" class="message-button">Play Again</button>
    </div>

    <script>
        // --- Three.js Setup ---
        let scene, camera, renderer, ambientLight, directionalLight;
        let sun, moon;
        let playerCar;
        let roadLines = [];
        let speedLines = [];
        let obstacles = [];
        let environmentObjects = [];
        let score = 0;
        let gameRunning = false;
        let animationFrameId;

        // Game Constants
        const PLAYER_TARGET_X_LERP_FACTOR = 0.1;
        let playerTargetX = 0;

        const INITIAL_LANE_SPEED = 0.1;
        const MAX_LANE_SPEED = 0.5;
        const SPEED_INCREASE_INTERVAL = 10000;
        const OBSTACLE_SPAWN_INTERVAL = 1000;
        const ENVIRONMENT_SPAWN_INTERVAL = 500;
        const MAX_OBSTACLES = 5;
        const MAX_ENVIRONMENT_OBJECTS = 10;

        const OBSTACLE_COLORS = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF];

        let lastObstacleSpawnTime = 0;
        let lastEnvironmentSpawnTime = 0;
        let lastSpeedIncreaseTime = 0;
        let currentLaneSpeed = INITIAL_LANE_SPEED;

        // Time of Day variables
        let gameTime = 0;
        const DAY_CYCLE_DURATION = 60; // in seconds
        
        // Time of Day color palettes
        const timeColors = {
            // Colors are in RGB format for easy interpolation
            earlyMorning: { background: new THREE.Color(0x87CEFA), light: new THREE.Color(0xFFA07A), ambient: 0.6 },
            afternoon: { background: new THREE.Color(0xADD8E6), light: new THREE.Color(0xFFFFFF), ambient: 1.0 },
            sunset: { background: new THREE.Color(0xFF6347), light: new THREE.Color(0xFFD700), ambient: 0.8 },
            night: { background: new THREE.Color(0x0A0A0A), light: new THREE.Color(0x404040), ambient: 0.2 },
        };

        // Camera shake variables
        let cameraShakeIntensity = 0;
        const MAX_CAMERA_SHAKE = 0.2;
        const CAMERA_SHAKE_DECAY = 0.05;

        // Steering variables
        let isTouching = false;
        let initialTouchX = 0;

        // HTML Elements
        const scoreDisplay = document.getElementById('scoreDisplay');
        const restartButton = document.getElementById('restartButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageBoxButton = document.getElementById('messageBoxButton');
        const gameCanvas = document.getElementById('gameCanvas');
        const startButton = document.getElementById('startButton');
        const startButtonContainer = document.getElementById('startButtonContainer');
        const touchControlArea = document.getElementById('touchControlArea');

        // --- Utility Functions ---

        // Show a custom message box instead of alert()
        function showMessageBox(message, onConfirm = () => {}) {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
            messageBoxButton.onclick = () => {
                messageBox.classList.add('hidden');
                onConfirm();
            };
        }

        // Creates a more realistic car model by combining multiple shapes
        function createPlayerCar() {
            const carGroup = new THREE.Group();

            // Car Body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x0077b6 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.5, 0);
            carGroup.add(body);

            // Car Cabin (Window area)
            const cabinGeometry = new THREE.BoxGeometry(1.3, 0.7, 1.5);
            const cabinMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1.1, -0.2);
            carGroup.add(cabin);

            // Wheels
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 12);
            
            // Front-left wheel
            const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontLeftWheel.position.set(-0.8, 0.2, 1);
            frontLeftWheel.rotation.x = Math.PI / 2;
            carGroup.add(frontLeftWheel);

            // Front-right wheel
            const frontRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontRightWheel.position.set(0.8, 0.2, 1);
            frontRightWheel.rotation.x = Math.PI / 2;
            carGroup.add(frontRightWheel);

            // Back-left wheel
            const backLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backLeftWheel.position.set(-0.8, 0.2, -1);
            backLeftWheel.rotation.x = Math.PI / 2;
            carGroup.add(backLeftWheel);

            // Back-right wheel
            const backRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backRightWheel.position.set(0.8, 0.2, -1);
            backRightWheel.rotation.x = Math.PI / 2;
            carGroup.add(backRightWheel);

            // Set the final position of the entire car group
            carGroup.position.set(0, 0.5, 5);

            return carGroup;
        }

        // Creates a more realistic obstacle car by combining multiple shapes
        function createObstacleCar() {
            const carGroup = new THREE.Group();
            const randomColor = OBSTACLE_COLORS[Math.floor(Math.random() * OBSTACLE_COLORS.length)];

            // Car Body
            const bodyGeometry = new THREE.BoxGeometry(1.5, 0.8, 3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: randomColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(0, 0.5, 0);
            carGroup.add(body);

            // Car Cabin (Window area)
            const cabinGeometry = new THREE.BoxGeometry(1.3, 0.7, 1.5);
            const cabinMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc, transparent: true, opacity: 0.8 });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 1.1, -0.2);
            carGroup.add(cabin);

            // Wheels
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 12);
            
            // Front-left wheel
            const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontLeftWheel.position.set(-0.8, 0.2, 1);
            frontLeftWheel.rotation.x = Math.PI / 2;
            carGroup.add(frontLeftWheel);

            // Front-right wheel
            const frontRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontRightWheel.position.set(0.8, 0.2, 1);
            frontRightWheel.rotation.x = Math.PI / 2;
            carGroup.add(frontRightWheel);

            // Back-left wheel
            const backLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backLeftWheel.position.set(-0.8, 0.2, -1);
            backLeftWheel.rotation.x = Math.PI / 2;
            carGroup.add(backLeftWheel);

            // Back-right wheel
            const backRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backRightWheel.position.set(0.8, 0.2, -1);
            backRightWheel.rotation.x = Math.PI / 2;
            carGroup.add(backRightWheel);

            return carGroup;
        }

        // Creates a more detailed bike obstacle
        function createObstacleBike() {
            const bikeGroup = new THREE.Group();
            const randomColor = OBSTACLE_COLORS[Math.floor(Math.random() * OBSTACLE_COLORS.length)];
            const bikeMaterial = new THREE.MeshLambertMaterial({ color: randomColor });
            const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });

            // Wheels
            const wheelGeometry = new THREE.TorusGeometry(0.5, 0.1, 16, 100);
            
            // Front wheel
            const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontWheel.rotation.x = Math.PI / 2;
            frontWheel.position.z = 1;
            bikeGroup.add(frontWheel);

            // Back wheel
            const backWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backWheel.rotation.x = Math.PI / 2;
            backWheel.position.z = -1;
            bikeGroup.add(backWheel);

            // Bike Frame (Main body)
            const frameGeometry = new THREE.BoxGeometry(0.2, 0.3, 2.5);
            const frame = new THREE.Mesh(frameGeometry, bikeMaterial);
            frame.position.y = 0.5;
            bikeGroup.add(frame);
            
            // Seat
            const seatGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.8);
            const seat = new THREE.Mesh(seatGeometry, bikeMaterial);
            seat.position.set(0, 0.7, -0.5);
            bikeGroup.add(seat);

            // Handlebars
            const handlebarsGeometry = new THREE.TorusGeometry(0.25, 0.05, 16, 100);
            const handlebars = new THREE.Mesh(handlebarsGeometry, bikeMaterial);
            handlebars.position.set(0, 0.8, 1);
            bikeGroup.add(handlebars);

            return bikeGroup;
        }
        
        // Creates a new environment object (tree, building or billboard)
        function createEnvironmentObject() {
            const rand = Math.random();
            let object;
            let randomX;
            const side = Math.random() > 0.5 ? 1 : -1; // 1 for right, -1 for left

            if (rand < 0.4) { // 40% chance for a building
                const buildingHeight = 5 + Math.random() * 15;
                const buildingWidth = 3 + Math.random() * 5;
                const buildingDepth = 3 + Math.random() * 5;
                const buildingGeometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
                const buildingMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0x888888 + 0xAAAAAA });
                object = new THREE.Mesh(buildingGeometry, buildingMaterial);
                object.position.y = buildingHeight / 2;
                // MODIFIED: Increased spawn distance for buildings
                randomX = side * (20 + Math.random() * 20);
            } else if (rand < 0.8) { // 40% chance for a tree
                const treeGroup = new THREE.Group();
                const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.5, 5, 8);
                const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 2.5;

                const leavesGeometry = new THREE.ConeGeometry(2, 4, 8);
                const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 5.5;

                treeGroup.add(trunk);
                treeGroup.add(leaves);
                object = treeGroup;
                // MODIFIED: Increased spawn distance for trees
                randomX = side * (15 + Math.random() * 10);
            } else { // 20% chance for a billboard
                const billboardHeight = 5 + Math.random() * 3;
                const billboardWidth = 8 + Math.random() * 2;
                const billboardGeometry = new THREE.BoxGeometry(billboardWidth, billboardHeight, 0.2);
                const billboardMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0x888888 + 0xAAAAAA });
                object = new THREE.Mesh(billboardGeometry, billboardMaterial);
                object.position.y = billboardHeight / 2 + 3; // Position above ground on some poles
                // MODIFIED: Increased spawn distance for billboards
                randomX = side * (18 + Math.random() * 10);

                // Add poles for the billboard
                const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, billboardHeight + 3, 8);
                const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const leftPole = new THREE.Mesh(poleGeometry, poleMaterial);
                leftPole.position.x = -billboardWidth / 2 + 1;
                const rightPole = new THREE.Mesh(poleGeometry, poleMaterial);
                rightPole.position.x = billboardWidth / 2 - 1;
                object.add(leftPole);
                object.add(rightPole);
            }

            object.position.set(randomX, 0, -60);
            scene.add(object);
            environmentObjects.push(object);
        }

        // Function to smoothly change colors based on game time
        function updateTimeOfDay() {
            gameTime += currentLaneSpeed * 0.05; // Game time increases based on speed
            const cycle = (gameTime % DAY_CYCLE_DURATION) / DAY_CYCLE_DURATION;
            let fromColor, toColor, fromAmbient, toAmbient, fromLight, toLight, lerpFactor;

            if (cycle < 0.25) { // Morning
                fromColor = timeColors.earlyMorning.background;
                toColor = timeColors.afternoon.background;
                fromAmbient = timeColors.earlyMorning.ambient;
                toAmbient = timeColors.afternoon.ambient;
                fromLight = timeColors.earlyMorning.light;
                toLight = timeColors.afternoon.light;
                lerpFactor = cycle / 0.25;
            } else if (cycle < 0.5) { // Afternoon
                fromColor = timeColors.afternoon.background;
                toColor = timeColors.sunset.background;
                fromAmbient = timeColors.afternoon.ambient;
                toAmbient = timeColors.sunset.ambient;
                fromLight = timeColors.afternoon.light;
                toLight = timeColors.sunset.light;
                lerpFactor = (cycle - 0.25) / 0.25;
            } else if (cycle < 0.75) { // Sunset
                fromColor = timeColors.sunset.background;
                toColor = timeColors.night.background;
                fromAmbient = timeColors.sunset.ambient;
                toAmbient = timeColors.night.ambient;
                fromLight = timeColors.sunset.light;
                toLight = timeColors.night.light;
                lerpFactor = (cycle - 0.5) / 0.25;
            } else { // Night
                fromColor = timeColors.night.background;
                toColor = timeColors.earlyMorning.background;
                fromAmbient = timeColors.night.ambient;
                toAmbient = timeColors.earlyMorning.ambient;
                fromLight = timeColors.night.light;
                toLight = timeColors.earlyMorning.light;
                lerpFactor = (cycle - 0.75) / 0.25;
            }

            // Lerp colors and light intensity
            const newBgColor = new THREE.Color().copy(fromColor).lerp(toColor, lerpFactor);
            const newLightColor = new THREE.Color().copy(fromLight).lerp(toLight, lerpFactor);
            const newAmbientIntensity = fromAmbient + (toAmbient - fromAmbient) * lerpFactor;
            
            scene.background = newBgColor;
            directionalLight.color = newLightColor;
            ambientLight.intensity = newAmbientIntensity;
        }

        // Function to update the position of the sun and moon
        function updateSunMoonPosition() {
            const angle = (gameTime / DAY_CYCLE_DURATION) * Math.PI * 2; // Full circle
            const radius = 50; // Distance from center
            const sunX = Math.cos(angle - Math.PI / 2) * radius;
            const sunY = Math.sin(angle - Math.PI / 2) * radius;
            
            // Adjust position for a nice visual arc
            directionalLight.position.x = sunX;
            directionalLight.position.y = sunY;
            
            // Set sun and moon positions
            sun.position.x = sunX;
            sun.position.y = sunY;
            sun.position.z = -50;
            
            moon.position.x = Math.cos(angle + Math.PI / 2) * radius;
            moon.position.y = Math.sin(angle + Math.PI / 2) * radius;
            moon.position.z = -50;

            // Show/hide sun and moon based on position
            if (sun.position.y > -5) {
                sun.visible = true;
                moon.visible = false;
            } else {
                sun.visible = false;
                moon.visible = true;
            }
        }

        // --- Game Initialization ---
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera (PerspectiveCamera for 3D depth)
            camera = new THREE.PerspectiveCamera(75, gameCanvas.offsetWidth / gameCanvas.offsetHeight, 0.1, 1000);
            camera.position.set(0, 5, 15); // Adjust camera position for better view
            camera.lookAt(0, 0, 0); // Point camera towards the origin

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(gameCanvas.offsetWidth, gameCanvas.offsetHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Lighting
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Soft white light
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Brighter light from a direction
            directionalLight.position.set(0, 10, 5);
            scene.add(directionalLight);

            // Player Car
            playerCar = createPlayerCar();
            scene.add(playerCar);

            // Road (a simple long plane)
            // MODIFIED: Increased width (10 -> 20) and length (100 -> 200) for expanded road
            const roadGeometry = new THREE.PlaneGeometry(20, 200, 1, 1);
            const roadMaterial = new THREE.MeshLambertMaterial({ color: 0x444444, side: THREE.DoubleSide });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.rotation.x = -Math.PI / 2; // Rotate to be flat on the ground
            road.position.set(0, 0, -90); // Extend road behind player (longer road requires deeper starting position)
            scene.add(road);

            // Sun and Moon
            const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            const moonGeometry = new THREE.SphereGeometry(2, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xE0E0E0 });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moon);


            // Initial Road Lines (Center Lines)
            // MODIFIED: Increased number of lines (20 -> 50) for denser road markings
            for (let i = 0; i < 50; i++) {
                createRoadLine(0, 0, -i * 5); // Spawn lines behind player
            }
            // Initial Speed Lines (Side Lines)
            // MODIFIED: Increased number of lines (30 -> 100) for more intense speed effect
            for (let i = 0; i < 100; i++) {
                // MODIFIED: Increased line separation from center (4 -> 9) to match wider road
                createSpeedLine(-9, -i * 3); // Left side
                createSpeedLine(9, -i * 3);  // Right side
            }
        }

        // Create a road line (3D object) for center
        function createRoadLine(x, y, z) {
            const lineGeometry = new THREE.BoxGeometry(0.2, 0.1, 2); // Thin, long box for line
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White line
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set(x, y, z);
            scene.add(line);
            roadLines.push(line);
        }

        // Create a speed line (3D object) for sides
        function createSpeedLine(x, z) {
            const lineGeometry = new THREE.BoxGeometry(0.1, 0.05, 1.5); // Very thin, short box
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan color for speed effect
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set(x, 0.1, z); // Slightly above road
            scene.add(line);
            speedLines.push(line);
        }

        // Create a new obstacle car
        function createObstacle() {
            // Randomly choose between a car and a bike
            const isCar = Math.random() > 0.5;
            const obstacle = isCar ? createObstacleCar() : createObstacleBike();

            // Random X position on the road
            // MODIFIED: Increased range from 6 to 12 to cover the wider road (from -6 to 6)
            const randomX = (Math.random() - 0.5) * 12;
            obstacle.position.set(randomX, 0.5, -60); // Start far ahead on Z-axis
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        // --- Game Logic ---
        function initGame() {
            // Hide start button and show restart button/controls
            startButtonContainer.classList.add('hidden');
            restartButton.classList.remove('hidden');
            touchControlArea.classList.remove('hidden');

            // Reset game state
            score = 0;
            currentLaneSpeed = INITIAL_LANE_SPEED;
            gameRunning = true;
            lastObstacleSpawnTime = performance.now();
            lastEnvironmentSpawnTime = performance.now();
            lastSpeedIncreaseTime = performance.now();
            scoreDisplay.textContent = score;
            playerTargetX = 0; // Reset player target X
            gameTime = 0; // Reset game time

            // Clear existing obstacles and environment objects from scene
            obstacles.forEach(obj => scene.remove(obj));
            environmentObjects.forEach(obj => scene.remove(obj));
            roadLines.forEach(obj => scene.remove(obj));
            speedLines.forEach(obj => scene.remove(obj));
            obstacles = [];
            environmentObjects = [];
            roadLines = [];
            speedLines = [];

            // Re-create initial road lines
            // MODIFIED: Increased number of lines (20 -> 50)
            for (let i = 0; i < 50; i++) {
                createRoadLine(0, 0, -i * 5);
            }
            // Re-create initial Speed Lines
            // MODIFIED: Increased number of lines (30 -> 100)
            for (let i = 0; i < 100; i++) {
                // MODIFIED: Increased line separation from center (4 -> 9)
                createSpeedLine(-9, -i * 3); // Left side
                createSpeedLine(9, -i * 3);  // Right side
            }

            // Reset player car position
            playerCar.position.set(0, 0.5, 5);

            // Start game loop
            startGameLoop();
        }

        function startGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function gameLoop(currentTime) {
            if (!gameRunning) return;

            // Apply camera shake if active
            if (cameraShakeIntensity > 0) {
                camera.position.x = playerCar.position.x + (Math.random() - 0.5) * cameraShakeIntensity;
                camera.position.y = 5 + (Math.random() - 0.5) * cameraShakeIntensity;
                cameraShakeIntensity = Math.max(0, cameraShakeIntensity - CAMERA_SHAKE_DECAY);
            } else {
                camera.position.x = playerCar.position.x; // Follow car smoothly horizontally
                camera.position.y = 5; // Fixed height
            }
             camera.lookAt(playerCar.position.x, playerCar.position.y, playerCar.position.z - 5);

            // Update time of day and sun/moon positions
            updateTimeOfDay();
            updateSunMoonPosition();

            // Move Road Lines (Center Lines)
            roadLines.forEach(line => {
                line.position.z += currentLaneSpeed * 2; // Move faster for line effect
                // MODIFIED: Reset line further back to cover longer view
                if (line.position.z > camera.position.z + 10) { 
                    line.position.z = -150; // Reset far back
                }
            });

            // Move Speed Lines (Side Lines)
            speedLines.forEach(line => {
                line.position.z += currentLaneSpeed * 5; // Much faster for speed illusion
                // MODIFIED: Reset line further back to cover longer view
                if (line.position.z > camera.position.z + 10) { 
                    line.position.z = -150; // Reset far back
                }
            });

            // Move Obstacles
            obstacles.forEach(obstacle => {
                obstacle.position.z += currentLaneSpeed; // Move obstacles towards player
            });
            
            // Move Environment Objects
            environmentObjects.forEach(obj => {
                obj.position.z += currentLaneSpeed * 0.5; // Move slightly slower than player for a depth effect
            });

            // Remove off-screen obstacles and update score
            obstacles = obstacles.filter(obstacle => {
                if (obstacle.position.z > camera.position.z + 5) { // If obstacle passes camera
                    scene.remove(obstacle);
                    score += 10;
                    scoreDisplay.textContent = score;
                    return false;
                }
                return true;
            });
            
            // Remove off-screen environment objects
            environmentObjects = environmentObjects.filter(obj => {
                if (obj.position.z > camera.position.z + 5) {
                    scene.remove(obj);
                    return false;
                }
                return true;
            });

            // Spawn new obstacles
            if (obstacles.length < MAX_OBSTACLES && (currentTime - lastObstacleSpawnTime) > OBSTACLE_SPAWN_INTERVAL) {
                createObstacle();
                lastObstacleSpawnTime = currentTime;
            }
            
            // Spawn new environment objects
            if (environmentObjects.length < MAX_ENVIRONMENT_OBJECTS && (currentTime - lastEnvironmentSpawnTime) > ENVIRONMENT_SPAWN_INTERVAL) {
                createEnvironmentObject();
                lastEnvironmentSpawnTime = currentTime;
            }

            // Increase speed over time
            if ((currentTime - lastSpeedIncreaseTime) > SPEED_INCREASE_INTERVAL && currentLaneSpeed < MAX_LANE_SPEED) {
                currentLaneSpeed += 0.05; // Smaller increment for 3D speed
                lastSpeedIncreaseTime = currentTime;
            }

            // Smooth player car movement towards target X
            playerCar.position.x += (playerTargetX - playerCar.position.x) * PLAYER_TARGET_X_LERP_FACTOR;

            // Collision Detection (Simplified AABB collision for now)
            obstacles.forEach(obstacle => {
                // Since the car is a group, we get the bounding box of each of its children
                const carBox = new THREE.Box3().setFromObject(playerCar);
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);

                if (carBox.intersectsBox(obstacleBox)) {
                    cameraShakeIntensity = MAX_CAMERA_SHAKE; // Activate camera shake
                    gameOver();
                }
            });

            // Render the scene
            renderer.render(scene, camera);
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- Game Over ---
        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            showMessageBox(`Game Over! Aapka score hai: ${score}`, initGame);
        }

        // --- Event Listeners ---

        // Mobile/Mouse Steering Controls
        touchControlArea.addEventListener('touchstart', (e) => {
            if (!gameRunning) return;
            isTouching = true;
            initialTouchX = e.touches[0].clientX;
        });

        touchControlArea.addEventListener('touchmove', (e) => {
            if (!isTouching) return;
            const currentTouchX = e.touches[0].clientX;
            const deltaX = currentTouchX - initialTouchX;

            // MODIFIED: Increased steering range from 3 to 10 to match wider road
            playerTargetX = Math.max(-10, Math.min(10, playerCar.position.x + deltaX * 0.05));
        });

        touchControlArea.addEventListener('touchend', (e) => {
            isTouching = false;
        });

        // Mouse controls for desktop
        touchControlArea.addEventListener('mousedown', (e) => {
             if (!gameRunning) return;
            isTouching = true;
            initialTouchX = e.clientX;
        });

        touchControlArea.addEventListener('mousemove', (e) => {
            if (!isTouching) return;
            const currentMouseX = e.clientX;
            const deltaX = currentMouseX - initialTouchX;
            // MODIFIED: Increased steering range from 3 to 10 to match wider road
            playerTargetX = Math.max(-10, Math.min(10, playerCar.position.x + deltaX * 0.05));
        });

        touchControlArea.addEventListener('mouseup', (e) => {
            isTouching = false;
        });


        // Event listener for the new "Start Game" button
        startButton.addEventListener('click', initGame);

        restartButton.addEventListener('click', initGame);
        messageBoxButton.addEventListener('click', initGame); // Also restart from message box

        // Handle window resize for responsiveness
        window.addEventListener('resize', () => {
            if (gameCanvas) {
                const newWidth = gameCanvas.offsetWidth;
                const newHeight = gameCanvas.offsetHeight;
                renderer.setSize(newWidth, newHeight);
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
            }
        });

        // Initial call to set up the scene when the window loads, but don't start the game
        window.onload = function () {
            initThreeJS(); // Initialize Three.js scene
        };
    </script>
</body>

</html>
